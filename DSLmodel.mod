#####################################################################
# Daily Soil Loss model - DSL 
#
# water balance and erosion on daily basis 
# Infiltration and runoff and flow and splash erosion 
# are done in 10 min intervals with a kinematic wave for Q and V
# this model does NOT do river flow and erosion, only slopes
#
# V. Jetten 27 May 2024, ITC
# version 1.0 GITHUB
#####################################################################


# arguments to run:
# $1=rainfolder $2=mapsfolder $3=resultfolder $4=somestring $5=infiltration $6=cohesion

#! --matrixtable --radians --lddout 

binding

### input maps ###

# these maps are generated by lisdbasegenerator: 
# https://github.com/vjetten/openLISEMdata/releases/tag/LISEM 

  ### input meteo and NDVI
  raininput = "$1/CHIR";   # list of maps CHIR0000.001, 002 etc , name is CASE SENSITIVE !
  etpinput  = "$1/ERA";    # list of maps ERA00000.001, 002 etc
  
  ndvi0 = "$1/ndvi_1.map";
  ndvi1 = "$1/ndvi_2.map";
  ndvi2 = "$1/ndvi_3.map";
  ndvi3 = "$1/ndvi_4.map"; 
  ndvi4 = "$1/ndvi_5.map";
  ndvi5 = "$1/ndvi_6.map";
  ndvi6 = "$1/ndvi_7.map";
  ndvi7 = "$1/ndvi_8.map";
  ndvi8 = "$1/ndvi_8.map";

  ### input maps
  DEM = "$2/dem.map";
  LDD = "$2/ldd.map";
  landuse = "$2/landuse.map";
  chanmask = "$2/chanmask.map";
  Ksat1 = "$2/ksat1.map";                # ksat map in mm/h
  theta_s = "$2/thetas1.map";            # porosity (fraction)
  thetainit = "$2/thetai1.map";          # initial moisture content
  theta_fc = "$2/fieldcap1.map";         # field capacity (fraction)
  theta_wp = "$2/wilting1.map";          # wilting point (fraction)
  Smax = "$2/smax.map";                  # max canopy storage, interception mm
  SD1 = "$2/soildep1.map";               # soildepth root zone 
  Kfactor = "$2/aggrstab.map";   	     # splash erosion g/J (EUROSEM)
  Coh = "$2/coh.map";                    # coh soil kPa
  CohVeg = "$2/cohadd.map";              # coh roots kPa
  D50 = "$2/d50.map";                    # Median grainsize distribution
  PH = "$2/ch.map";                      # plant height m 
  RR = "$2/rr.map";                      # micro roughness (cm)

# not used
#  chanwidth = "$2/chanwidt.map";
#  chanheight = "$2/chanheight.map";
#  LDDchan ="$2/lddchan.map";

### calibration factors ###

  infil_cal = $5;     # lower is more runoff, calibration factor Ksat, influences infiltration  
                      # calibrate until the fraction runoff is acceptable
  coh_cal = $6;      # lower is more flow erosion 
  Splash_cal = 1.0;   # lower is less splash erosion  
  rain_fact = 2.0;    # CHECK if the rainfall images are in mm/day, if so set this factor to 1.0 

### Output maps

  SoilMoisture = "$3/moist$4a";              # daily soil moisture maps (mm)
  Pcum = "$3/raintotal$4.map";               # cumulative rainfall map (mm)
  ds_map = "$3/ds$4.map";                    # splash detachment ton/ha
  df_map = "$3/df$4.map";                    # flow detachment ton/ha
  dep_map = "$3/dep$4.map";                  # deposition detachment ton/ha
  Soilloss_map = "$3/Soilloss$4.map";        # soiloss detachment ton/ha
  erosrate_map = "$3/SoilLossClass$4.map";   # classified soil loss (1-6)

# output tables

  P_tss = "$3/Pday$4.tss";                # average daily Rain mm
  Pcum_tss = "$3/Pcum$4.tss";		      # average cumulative Rain mm
  ETpcum_tss = "$3/ETpcum$4.tss";         # average cumulative ETp mm
  ETpavg_tss = "$3/ETpday$4.tss";         # average daily ETp (mm)
  eta_tss = "$3/ETaday$4.tss";            # average daily ETa (mm)
  etacum_tss = "$3/ETacum$4.tss";         # average cumulative ETa (mm)
  intccum_tss = "$3/interccum$4.tss";     # average cumulative interception (mm)
  runoff_tss = "$3/rocum$4.tss";          # average WH surface (mm)
  infil_tss = "$3/infcum$4.tss";          # average infiltration (mm)
  perc_tss = "$3/perccum$4.tss";          # average percolation (mm)
  theta_tss = "$3/theta$4.tss";           # average daily theta  (-)
  moisture_tss = "$3/moisture$4.tss";     # average daily soil moisture (mm) 
  LUtheta_tss = "$3/thetaLU$4.tss";       # theta per landuse
  Soillosslu_tss = "$3/SoillossLU$4.tss"; # soil loss per landuse ton/ha
  Soilloss_tss = "$3/Soilloss$4.tss";     # average soil loss ton/ha
  Cover_tss = "$3/cover$4.tss";           # average vegetation cover fraction (-)
  rofract_tss = "$3/rofract$4.tss";       # runoff fraction


areamap
  DEM;
   
timer
  1 122 1;  # run days in growing season 

initial

  hoursrain = 1.0;    # nr hours it rains on average, influences infl
  dt = scalar(600);   # 10 min is 600 sec
  maxcount = 3600/dt*hoursrain; # nr of 10 min timesteps for kin wave

  mask = scalar(DEM gt 0);
  outlet = pit(LDD);

  nrCells = maptotal(if(chanmask eq 1,0,mask)); #maptotal(mask);
  
  count = 1*mask; # used to count rainy days
  nLU = ordinal(landuse); # output

  #############################################  
  ### read soil and vegetation related data ###
  ############################################# 
  
  Kc = 1.0;                      # FAO crop factor Kc
  day = scalar(1);               # day counter, not really used at the moment!

  Ksat = Ksat1 * mask;           # saturated conductivity mm/h
  theta = thetainit;             # initialize soil moisture theta 
  SoilMoisture = theta*SD1;      # initial soil moisture in mm 

  ks = ln(min(1000.0,max(0.5,Ksat)));
  lambda = max(0.1, min(0.7, 0.0849*ks+0.159));	#Brooks Corey lambda needed for percolation
  psi = (exp(-0.3382*ks)+3.3425); #psi suction front infiltration, cm

  # Govers transport capacity factors
  Cg = ((D50+5)/0.32)**-0.6;
  Dg = ((D50+5)/300)**0.25;
  
  Grad = slope(DEM) + 0.005;
  Grad = if(chanmask eq 1,0.01,Grad);

  #https://www.researchgate.net/publication/266227873_A_simple_formula_for_predicting_settling_velocity_of_sediment_particles
  # fall velocity
  GRAV = 9.81;
  Vs = 2*(2650.0-1000.0)*GRAV*((D50/2000000.0)**2)/(9*0.001);  # Stokes settling velocity if D50 < 100

  ########################################
  ### Initialize vegetation cover maps ###
  ########################################  

  daycov0 = 1;
  daycov1 = 16;
  daycov2 = 32;
  daycov3 = 48;
  daycov4 = 54;
  daycov5 = 70;
  daycov6 = 86;
  daycov7 = 102;
  daycov8 = 122;

# corrections: if a value in a ndvi map is less than 0.2 (suspiciopus/cloud)
# AND the values of the previous AND next images are higher, so it presents a dip, than take the average 
# of the previous and the next inmage, else take the recorded ndvi value
  thr = 0.2;
 
  ndvia = ndvi0;
  ndvib = ndvi1;
  ndvic = ndvi2;
  ndvi1 = if ((ndvib lt thr) and (ndvia gt thr) and (ndvic gt thr) and (ndvia gt ndvib) and (ndvic gt ndvib),(ndvia+ndvic)/2.0,ndvib);
  
  ndvia = ndvi1;
  ndvib = ndvi2;
  ndvic = ndvi3;
  ndvi2 = if ((ndvib lt thr) and (ndvia gt thr) and (ndvic gt thr) and (ndvia gt ndvib) and (ndvic gt ndvib),(ndvia+ndvic)/2.0,ndvib);
  
  ndvia = ndvi2;
  ndvib = ndvi3;
  ndvic = ndvi4;
  ndvi3 = if ((ndvib lt thr) and (ndvia gt thr) and (ndvic gt thr) and (ndvia gt ndvib) and (ndvic gt ndvib),(ndvia+ndvic)/2.0,ndvib);
  
  ndvia = ndvi3;
  ndvib = ndvi4;
  ndvic = ndvi5;
  ndvi4 = if ((ndvib lt thr) and (ndvia gt thr) and (ndvic gt thr) and (ndvia gt ndvib) and (ndvic gt ndvib),(ndvia+ndvic)/2.0,ndvib);
  
  ndvia = ndvi4;
  ndvib = ndvi5;
  ndvic = ndvi6;
  ndvi5 = if ((ndvib lt thr) and (ndvia gt thr) and (ndvic gt thr) and (ndvia gt ndvib) and (ndvic gt ndvib),(ndvia+ndvic)/2.0,ndvib);
  
  ndvia = ndvi5;
  ndvib = ndvi6;
  ndvic = ndvi7;
  ndvi6 = if ((ndvib lt thr) and (ndvia gt thr) and (ndvic gt thr) and (ndvia gt ndvib) and (ndvic gt ndvib),(ndvia+ndvic)/2.0,ndvib);

  ndvia = ndvi6;
  ndvib = ndvi7;
  ndvic = ndvi8;
  ndvi7 = if ((ndvib lt thr) and (ndvia gt thr) and (ndvic gt thr) and (ndvia gt ndvib) and (ndvic gt ndvib),(ndvia+ndvic)/2.0,ndvib);

  #########################
  ### initialize totals ###
  #########################

  interception = 0*mask;
  Pcum = 0*mask;
  ETpcum = 0*mask;
  ETacum = 0*mask;
  intccum = 0*mask; 
  infilcum = 0*mask;
  perccum = 0*mask;
  rocum = 0*mask;
  rocumout = 0*mask;
  Qtot = 0*mask;
  dx = celllength();

  Sed = 0*mask;
  erosion = 0*mask;
  deposition= 0*mask;
  Dscum =0*mask;
  Dfcum = 0*mask;
  Depcum = 0*mask;
  ETfcum = 0*mask;
  Conc = 0*mask;
 
dynamic

  ########################
  ### meteo data input ###
  ########################

  rain = timeinput(raininput)*mask/rain_fact;
  
  report P_tss = maptotal(rain)/nrCells;
  
  report Pcum = Pcum + rain;
  #calculate cumulative P for outut

  report Pcum_tss = maptotal(Pcum)/nrCells;   
  # write a graph of the average cumulative rainfall

  # hoursrain = if (rain gt 10, 2.0, 1.0);

  # ETo = timeinput(ETpinput)*mask;
  # ETo = timeinputscalar(ETo_tss, nominal(mask));    # read potential evapotranspiration from a file and give the whole area that value
 
  #Tahir, Mekete & Mengistu, Ashenafi & Mersso, Berhan. (2018). 
  ETo = 4.2*mask;
  ETo = if(day gt 30, 3.0, ETo);
  ETo = if(day gt 61, 3.1, ETo);
  ETo = if(day gt 92, 3.5, ETo);
  ETo = if(day gt 122, 3.9, ETo);
    
  Kc = 1.0; # 
  ETp = Kc * ETo;
  ETpcum = ETpcum + ETp;


  ######################################
  ### vegetation ndvi interpolation ###
  ######################################     
    
  #linear interpolation between two images
  Ndvi = ndvi0*mask;
  Ndvi = if (day ge daycov0, ndvi0 + (day - daycov0)/(daycov1-daycov0 +0.01)*(ndvi1-ndvi0), Ndvi); 
  Ndvi = if (day ge daycov1, ndvi1 + (day - daycov1)/(daycov2-daycov1 +0.01)*(ndvi2-ndvi1), Ndvi); 
  Ndvi = if (day ge daycov2, ndvi2 + (day - daycov2)/(daycov3-daycov2 +0.01)*(ndvi3-ndvi2), Ndvi); 
  Ndvi = if (day ge daycov3, ndvi3 + (day - daycov3)/(daycov4-daycov3 +0.01)*(ndvi4-ndvi3), Ndvi); 
  Ndvi = if (day ge daycov4, ndvi4 + (day - daycov4)/(daycov5-daycov4 +0.01)*(ndvi5-ndvi4), Ndvi); 
  Ndvi = if (day ge daycov5, ndvi5 + (day - daycov5)/(daycov6-daycov5 +0.01)*(ndvi6-ndvi5), Ndvi); 
  Ndvi = if (day ge daycov6, ndvi6 + (day - daycov6)/(daycov7-daycov6 +0.01)*(ndvi7-ndvi6), Ndvi); 
  Ndvi = if (day ge daycov7, ndvi7 + (day - daycov7)/(daycov8-daycov7+0.01)*(ndvi8-ndvi7), Ndvi); 
  Ndvi = if (day ge daycov8, ndvi8, Ndvi); 
 # Ndvi = if (day ge daycov8, ndvi8 + (day - daycov8)/(daycov9-daycov8+0.01)*(ndvi9-ndvi8), Ndvi); 
 # Ndvi = if (day ge daycov9, ndvi9 + (day - daycov9)/(daycov10-daycov9+0.01)*(ndvi10-ndvi9), Ndvi); 
 # Ndvi = if (day ge daycov10, ndvi10 + (day - daycov10)/(daycov11-daycov10+0.01)*(ndvi11-ndvi10), Ndvi); 
 # Ndvi = if (day ge daycov11, ndvi11 + (day - daycov11)/(daycov12-daycov11+0.01)*(ndvi12-ndvi11), Ndvi); 
 # Ndvi = if (day ge daycov11, ndvi12, Ndvi); 

  Ndvi = cover(Ndvi,0)*mask;
  NDVI = min(1.0,max(0,Ndvi));                         
  #make sure NDVI is between 0 and 1!
  
  #Cover = 1 -exp(-2*NDVI/(1.5 - NDVI));              # Converting NDVI values to Cover factor according to Van der Knijff et al., 1999
  a_ = 4.257;
  b_ = 100.719;
  c_ = -5.439;
  Cover = min(0.99,max(0.0,a_*NDVI*NDVI + b_*NDVI + c_)/100.0)*mask;
  Litter = Cover;

  N = 0.01*RR + 0.1*Cover;   # mannings n depends on cover
  N = if(chanmask eq 1,0.05,N);

  Cohesion = coh_cal*max(-1,Coh + Cover*CohVeg);
  Cohesion = if (chanmask eq 1,-1,Cohesion);

  #################################
  ######### Interception ##########
  #################################

  interception = interception + rain - ETp;                 # add rainfall and subtract evaporation from interception
  interception = min(Smax, interception);                   # fill up the interception with rain, make sure water has Smax = 0   
  interception = max(0, interception);                      # interception cannot be less than 0
  Pe = max(rain - interception, 0);                         # Estimating effective rainfall (mm)
  intccum = intccum + interception;                         # cumulating interception

 
  ###############################
  ### Infiltration and Runoff ###
  ###############################

  count = 0;

  W = dx/3; # flow width m, water is concentrated in 1/3 of the gridcell
  Infilday = 0;  # to calc daily infiltration

  WHavg = 0*mask;

  ###loop that does the fast processes per 10 min and uses a kin wave for routing
  repeat {
     
    #################################
    ######### Surface water #########
    #################################
  
    Pinterval = rain*exp(-0.693*(count+1)); #mm/dt
    # this gives a rainfall for each step that is Pe/2, Pe/4, Pe/8 etc. an exponential decline

##    interception = interception + Pinterval ;                 # add rainfall, assume there is no evaporation during rain!
##    interception = min(Smax, interception);                   # fill up the interception with rain, make sure water has Smax = 0   
##    interception = max(0, interception);                      # interception cannot be less than 0
##    Pinterval = max(Pinterval - interception, 0);                         # Estimating effective rainfall (mm)
 
    ### infiltration ###
    store = max(0.0, theta_s-theta)*SD1;                      # effective storage in mm
    #Infilcap = infil_cal*hoursrain/maxcount*Ksat*mask;        # infil is a fraction of Ksat 
    
    Ip = infil_cal*hoursrain/maxcount*Ksat*((theta_s-theta)*psi/(Infilday+0.1)+1);
    # Green and Ampt
    Infilcap = min(store, Ip);      
    # infiltration in mm, is smallest of storage or potential infil
    Infil = min(Infilcap, Pinterval);
    # infiltration in mm, is smallest of Infil or rainfall
       
    Infilday = Infilday + Infil;
	# cumulative infil for this day
  
    infilcum = infilcum + Infil;
    # infil cumulative in mm on points for all days

    ### Runoff water height ###
    WH = cover(max(0, Pinterval-Infilcap)*0.001,0)*mask;  #waterheight in m avg per hour, 0.001 from mm to m
    WH *= dx/W;  # assume the flow is concentrated over 1/3 of the gridcell

    ### kinematic wave ###
    # manning's velocity and discharge and alpha: A = alphaQ^0.6    
    V = WH**(2/3)*sqrt(Grad)/N;
    Q = V * WH * W;
    alpha =(N/sqrt(Grad) * (W**(2.0/3.0)))**0.6;
    ts = ordinal(10);         # not sure what this is    
    Qn = kinematic(LDD, Q, 0, alpha, 0.6, ts, dt, dx);

    # new Q, alpha and WH after kin wave
    Qn = cover(Qn,0)*mask;
    A = alpha*(Qn**0.6);
    WH = A/W;
    # new water height   
    V = WH**(2/3)*sqrt(Grad)/N;
    # new velocity for flow erosion
	
    Vol = WH*W*dx;
    # volume water needed for sed concentration
  
    WHavg = WHavg + WH;
    # average wh needed for output
    #Qavg = Qavg + Qn;
 
    ###########################
    ######### Erosion #########
    ###########################
  
    ### Kinetic energy of rainfall in J/m2 and SPLASH Ds ###

    # kinetic energy calculations for splash detachment
    # DT = direct rainfall on open part of the gridcell, 
    # LD is leaf drainage from covered part

    Intensity = Pinterval*3600/dt;
    # avg rainfall intensity in mm/h
    KE_DT = (1-Cover)*28.3*(1-0.52*exp(-0.042*Intensity))*Pinterval;          # kinetic energy of direct rainfall     
    KE_LD = (1-Litter)*Cover*Pinterval*max(0, 15.3*sqrt(PH) - 5.87);            # kinetic energy of LD in J/m2 proposed by Brandt (1990)
    
    KE = if(rain eq 0, 0, KE_DT + KE_LD);                     # total kinetic energy of rainfall
    splashfactor = (W+0.15*(dx-W))/dx;                        # splash from the dry part in a gridcell to the runoff flowing part
    Ds = Splash_cal*splashfactor*Kfactor*KE*0.001*cellarea(); # detachment by raindrop g/J * J/m2 * 0.001 = kg/m2 * cell size = kg
    Ds = if(Kfactor eq -1, 0,Ds);
    #Ds = Ds * exp(-1.48*WH*1000);                   # no splash when the water is deep then a few mm
    Ds = if (WH gt 0, Ds, 0);                       # splash erosion when there is no water at the surface does not count 
    Sed = Sed + Ds;                                 # add splash sediment to flow and cal concentration for flow detachment  
    Conc = min(840, if (Vol gt 1e-6, Sed/Vol, 0));  # 840 kg/m3 is the highest conc before the flow is considered mudflow and mannings eq is no longer valid
  
    ##############################################
    ### transport, flow detachment, deposition ###
    ##############################################
  
    ### transport capacity in kg/m3

    rho_s = 2650;                 # specific density grains (quartz)  kg/m3
    omega = Grad*max(0,V-0.004);  # unit stream power  m/s
   
    TC = rho_s*Cg*(omega**Dg);  # transport capacity Govers et al. 1995
   
    Y = cover(if (Cohesion le 0, 0, 1/(2*Cohesion)),0)*mask; 
    # soil strength factor 0-1, from MMF
   
    # Y = cover(if (Cohesion le 0, 0, 0.79*exp(-0.85*Cohesion)),0)*mask; 
    # soil strength factor 0-1, from Eurosem
   
    Df  = max(TC-Conc,0)*Y*Vs*dt*W*dx;  # flow detachment in kg/celll:  kg/sec/m3 * m/s *m*m* sec = kg/cell  
    Df = if(chanmask > 1, 0, Df);

    # potential deposition in kg/cell (negative)   #kg/m3 * (-) * m3/cell  = kg/cell
    Dep = min(TC-Conc,0)*Vs*dt*W*dx;
    Dep = if (WH gt 0.0001, min(TC-Conc,0)*(1-exp(-dt*Vs/WH))*Vol, 0);  
    Dep = min(0, max(Dep, -Sed))*mask;       
    # not more deposition than there is sediment
    
    #exclude channel cells, these are not channel equations
    Df = if(chanmask eq 1,0,Df);   
    Dep = if(chanmask eq 1,0,Dep);
  
    # cumulative for display
    Dfcum = Dfcum + Df;    
    Depcum = Depcum + Dep;
    Dscum = Dscum + Ds;

    erosion = Df+Ds+Dep + erosion;         # cumulating soil loss  (detachment - deposition, is net loss)                       
  

    count = count + 1;   
  } until count >= maxcount; #1 or more hours

  #####################################
  ### THE REST OF THE WATER BALANCE ###
  ##################################### 

##  interception = max(0, interception - ETp);
##  intccum = intccum + interception;                         # cumulating interception
  # evaporate the interception water after the rainfall


  ### Actual Evapotranspiration ###

  # actual evapotranspiration ETa linear with soil moisture content (mm)
  ETpoint = theta_wp + (theta_fc - theta_wp)*2/3;
  ETfactor = if (theta gt ETpoint, 1.0, 0.0);
  ETfactor = if (theta lt ETpoint and theta ge theta_wp,(theta-theta_wp)/(ETpoint-theta_wp), ETfactor);
  ETfactor = if (theta lt theta_wp, 0.0, ETfactor);
  #ETfactor = cover(ETfactor, 0.0001); #????
         
  Ta = ETp * ETfactor * Cover;                                # actual transpiration (mm)
  Ea = ETp * theta/theta_s * (1-Cover);                       # actual soil evaporation (mm)
  ETa = Ea + Ta;                                              # ETa sum of the Evap and Transp  
  #ETa = if(landuse eq RICE or chanmask eq 1, ETp, ETa);                        # ETa equals ETp in case of water body
  ETa = min(ETa, SoilMoisture);                               # cannot be more than soil moisture present
 
  # graphs with average and cumulative average ETa of all cells
  ETacum = ETacum + ETa;
  ETFactor = ETa/ETp;  
  #ETfcum = ETfCum + ETFactor;
                                       # recalculating true ETFactor based on final ETa/ETp 
  ETE0fac = areaaverage(ETfactor, nLU);

  ### Percolation ###
  
  Perc = 24.0*Ksat*(theta/theta_s)**(2+3/lambda);  
  Perc = if(theta lt theta_wp, 0, Perc);
  Perc = min(SoilMoisture, Perc);
  perccum = perccum + Perc;

  ### water balance: new soil moisture ###

  SoilMoisture = SoilMoisture + (Infilday - ETa - Perc);
  SoilMoisture = min(SoilMoisture, theta_s*SD1);
  SoilMoisture = max(0, SoilMoisture);                # soil moisture cannot be negative
  theta = SoilMoisture/SD1*mask;                      # findng soil moisture at surface
  se = theta/theta_s;

  #################################
  ### reporting maps and graphs ###
  #################################
 
  report Cover_tss = timeoutput(nLU, areaaverage(Cover, nLU));    
  # report avg cover per land use type in a graph

  report etpcum_tss = maptotal(ETpcum)/nrCells;
  report eta_tss = maptotal(ETa)/nrCells;                    
  report etacum_tss = maptotal(ETacum)/nrCells;
  report ETfact_tss = maptotal(ETfactor)/nrCells;           # computing time series ETFactor

  report intccum_tss = maptotal(intccum)/nrCells;    
  report infil_tss = maptotal(infilcum)/nrCells; # cumulative infil 
  report LUtheta_tss = timeoutput(nLU,theta);

  # total runoff in the area
  rocum = rocum + WHavg/maxcount*1000; 
  report runoff_tss = maptotal(rocum)/nrCells;  # cumulative water surface 

  # outflow of the area. Because we do not have a complete kin wave
  # we assume that all water in the channel reaches the outlet in a day

### kinematic wave approach:
##  WHch = if(chanmask gt 0,WHavg/maxcount,0);
##  Pch = (chanwidth+2*WHch);
##  Ach = (chanwidth*WHch);
##  alphach =(N/sqrt(Grad) * ((chanwidth+2*WHch)**0.667))**0.6;
##  Qch = (Ach/alphach)**(5.0/3.0);
##  #Qch = Ach * ((Ach/Pch)**0.667)*sqrt(Grad)/0.05;
##  
##  ts = ordinal(50);         # not sure what this is
##  ktime = 8*3600; # 4 hours flow
##  Qnch = kinematic(LDDchan, Qch, 0, alphach, 0.6, ts, ktime, dx);
##  Qnch = cover(Qnch,0)*mask; # m3/s
##  report qn$3.tss = timeoutput(outlet,Qnch);
##  Qtot += Qnch*ktime;
##  rocumout = maptotal(if(outlet ne 0, Qtot, 0)/cellarea()*1000)/nrcells;
##  report qtotmm$3.tss = timeoutput(outlet,rocumout);
##
##  Qtot = Qtot + Qavg/maxcount*dt*chanmask * chanwidth/dx;   # flow in channel cells m3
##  rocumout = maptotal(Qtot/cellarea()*1000)/nrCells;
##  WHch = if(chanmask gt 0,WH*chanwidth/dx,0);
##  Qtot = Qtot + WHch;


  report rofract_tss = timeoutput(outlet, maptotal(rocum)/maptotal(Pcum+1)); 
  report perc_tss = maptotal(perccum)/nrCells;

  # converting from kg/gridcell to ton/ha kg: kg to ton factor 1000 
  # gridcell area to ha: # kg/gridcell /cellarea() *10000 = kg/ha /1000 = ton/ha
  # so (10000/1000)/cellarea()
  factor = 10/cellarea();
  report ds_map = Dscum*factor;
  report df_map = Dfcum*factor;
  report dep_map = Depcum*factor;

  # soil loss is the net positive detachment in ton/ha, expressed per gridcell. Note that a gridcell is less than a ha 
  soilloss = max(0, erosion*factor);            
        
  report Soilloss_map = soilloss;
  report Soilloss_tss= maptotal(soilloss)/nrCells;   # area avg soilloss ton/ha
  report Soillosslu_tss = timeoutput(nLU, soilloss); # soilloss per land unit ton/ha

  # classify with FAO classification
  erosrate = scalar(
    if(soilloss ge 0 and soilloss lt 2, 0, 
    if(soilloss ge 2 and soilloss lt 5, 1, 
    if(soilloss ge 5 and soilloss lt 10, 2, 
    if(soilloss ge 10 and soilloss lt 20, 3, 
    if(soilloss ge 20 and soilloss lt 50, 4, 
    if(soilloss ge 50 and soilloss lt 100, 5, 6)))))));
  report erosrate_map = ordinal(erosrate);

  # set everything to zero for the next day, 
  # we assume there is no runoff that lasts until the ext day
  Sed = 0;
  Conc = 0;
  Vol = 0;
  WH = 0;  

  day = day + 1;
